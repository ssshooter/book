<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What is Ownership? - The Rust Programming Language</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#什么是-ownership" id="什么是-ownership">什么是 ownership？</a></h2>
<p><strong>Ownership</strong> 是 Rust 的重要特性。尽管这个特性直接解释起来不难，但是它深远地影响着这个语言的每一部分。</p>
<p>所有程序都需要解决他们在运行时如何使用计算机内存的问题。
一些语言有垃圾收集系统（GC），GC 会在程序运行时自动寻找可以释放的内存，
在另一些语言，程序员需要显式分配和释放内存。
而 Rust 使用第三种方式：在编译时，ownership 系统借助<strong>编译器</strong>的一系列检查规则管理内存。
任何 ownership 特性都不会让拖慢程序的运行速度。</p>
<p>因为 ownership 对很多程序员来说都是全新的概念，需要花点时间习惯它。
好消息是，你对 Rust 和 ownership 系统的规则越熟悉，
越能自然地写出安全高效的代码。加油！</p>
<p>当你理解 ownership，你就有了理解其他 Rust 特性的巩固基础。
在这一章，你将通过十分常见的数据结构——字符串，来学习 ownership。</p>
<blockquote>
<h3><a class="header" href="#栈stack和堆heap" id="栈stack和堆heap">栈（stack）和堆（heap）</a></h3>
<p>在很多语言中，你基本不需要钻研栈和堆。但在 Rust 这样的语言，
一个值存在栈或堆会对语言的行为产生影响，所以你需要在此作出正确的选择。
这章后面的 ownership 部分会描述它与堆和栈的关系，这里仅是提前做些简单的解释。</p>
<p>堆和栈都是代码在运行时可以调用的一部分内存，但是它们的结构有所不同。
栈的储存顺序与获取顺序相同，与删除顺序相反，这就是所谓<strong>后进先出</strong>。
就像一叠盘子，放盘子的时候你会放在一叠盘子的最上方，而取盘子的时候你会拿走最上面的一个。
你想在中间和底部加盘子都很不方便！添加数据我们称为<strong>推入栈中</strong>，取出数据称为<strong>弹出栈</strong>。</p>
<p>储存在栈的数据必须有一个已知且固定的长度。而在编译时未知长度，或长度会改变的数据，则储存在堆中。
堆相对栈没有那么强的组织性：数据放入堆时，你申请了一部分空间。
内存分配器找到一块足够你使用的空位，将其标记为已使用，
然后返回一个指向该地址的<strong>指针</strong>。这个过程称为<strong>在堆中分配内存（allocating on the heap）</strong>，有时缩写为<strong>分配（allocating）</strong>。
推入栈的操作不属于分配，因为那个指针是已知的，固定长度的，你可以在栈中储存指针，但你想获取实际数据，就必须跟随指针寻找。</p>
<p>举一个你去餐厅的例子。进餐厅时，你告诉服务员有多少人用餐，然后服务员找到合适的桌子并带你到那里。
如果你的伙伴们晚了来，他们就可以问出你在哪并找到你。</p>
<p>推入栈比堆分配更快，因为数据总会存在栈顶，分配器不需要寻找存放新数据的位置，而堆在分配空间时需要做更多的工作，
因为分配器必须找到一块足够大的地方存放数据，并进行记录以备下次再使用。</p>
<p>访问堆里的数据比访问栈数据要慢，因为你要跟随指针获取数据。如果不在内存中反复横跳，近代处理器会更快一些。
继续刚才的比喻，餐厅服务员给很多桌客人下单，最快的方法就是一张桌子全都下完单，再到下一张桌子，
如果先给 A 下单一个菜，然后给 B 下单，又再回到 A，就会非常缓慢。同样的，处理器可以更快地当前数据临近的数据
（就像栈这样的结构），而远的就会变慢（堆）。同时，在堆中分配空间也消耗时间。</p>
<p>当你的代码调用函数，值（也有可能是指向堆数据的指针）会被传入函数，
然后函数的本地变量会被推入栈中，函数运行结束，这些变量会被弹出。</p>
<p>Ownership 要做的就是保持跟踪不同的代码使用堆中的不同数据，
最小化堆中的重复数据、清除无用数据，保证你的内存不会爆炸。
一旦你理解 ownership，你就不用整天关注堆和栈，不过知道管理堆数据是 ownership 的存在意义，
可以帮助你理解它为什么要如此设计。</p>
</blockquote>
<h3><a class="header" href="#ownership-规则" id="ownership-规则">Ownership 规则</a></h3>
<p>首先，我们看看 ownership 的几条规则，记住这些规则，再看看下面详细介绍的例子：</p>
<ul>
<li>Rust 里的每个值都有一个叫 <strong>owner</strong> 的变量。</li>
<li>一个值同时只能有一个 owner</li>
<li>owner 离开作用域时，值将被抛弃（drop）</li>
</ul>
<h3><a class="header" href="#变量作用域" id="变量作用域">变量作用域</a></h3>
<p>第二章中已经学习过几个 Rust 程序的实例，现在我们不关心基础的语法问题，
暂时去掉 <code>fn main() {</code>，如果你想跟着做，需要手动加上 <code>main</code> 函数。
这样，我们的例子会更简洁，让我们更关注我们需要关注的细节。</p>
<p>来看看 ownership 的第一个例子，变量的<strong>作用域</strong>。
作用域是在程序里的一个范围，在这个范围内，变量是有效的。
举个例子，我们有一个变量 <code>s</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>变量 <code>s</code> 指向一个字符串字面量（string literal），这个值是写死在程序中的。
这个变量从声明到当前<strong>作用域</strong>结束，是可用的。例 4-1 的注释说明了 <code>s</code> 的使用范围。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = &quot;hello&quot;;   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">例 4-1：变量与它的有效作用域</span></p>
<p>换言之，有两个重点：</p>
<ul>
<li><code>s</code> <strong>进入作用域</strong>，那么它是有效的</li>
<li>直到<strong>脱离当前作用域</strong>，一直有效</li>
</ul>
<p>暂时为止，作用域和变量有效性的关系与其他语言基本一样。现在我们在此基础上，介绍 <code>String</code> 类型。</p>
<h3><a class="header" href="#string-类型" id="string-类型"><code>String</code> 类型</a></h3>
<p>为了说明 ownership 的规则，我们需要一种比第三章提到的更复杂的<a href="ch03-02-data-types.html#data-types">数据格式</a><!-- ignore -->。
之前提到的类型都储存于栈中，在离开作用域时，弹出栈，但我们现在要研究储存于堆中的数据，
并搞清楚 Rust 如何清理这些数据。</p>
<p>例子中我们使用 <code>String</code>，并关注它与 ownership 的关系。
它的表现与其他复杂数据类型（不管是标准库提供还是你自己创建的）类似。我们将会在第八章深入讨论 <code>String</code>。</p>
<p>上面已经使用过字符串字面量，也就是字符串的值写死到程序中。字符串字面量很方便，但不能适应各种情况，
原因就是他们是不可变的（immutable）。不是所有字符串的值都是确定的，例如我们想获取用户输入然后储存起来要怎么办？
要应付这种情况，Rust 提供第二种字符串类型，<code>String</code>。这个类型分配堆空间，可以存放一些我们在编译时未确定的文本。
你可以通过 <code>from</code> 函数由字符串字面量创建 <code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>双冒号（<code>::</code>）操作符让你在 <code>String</code> 命名空间下使用 <code>from</code> 函数，而不是通过 <code>string_from</code> 之类的方法。
我们会在第五章 <a href="ch05-03-method-syntax.html#method-syntax">“Method Syntax”</a><!-- ignore --> 部分讨论更多语法，
在第七章 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore -->
讨论命名空间和模块化。</p>
<p>这种字符串是<strong>可以</strong>被修改的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>那么这里面有什么不同？为什么 <code>String</code> 可以被修改但是字面量不可以呢？
其中缘由就是他们在内存中的两种不同处理方式。</p>
<h3><a class="header" href="#内存与分配allocation" id="内存与分配allocation">内存与分配（Allocation）</a></h3>
<p>在字符串字面量的例子中，我们在编译时就确定了内容，所以文本直接写死到最后的可执行文件。
这就是文本字面量快速高效的原因。但这些好处来源于字符串字面量的不变性。
我们不能把大小未知或在运行时会遭到修改的文本编译为二进制文件。</p>
<p>使用 <code>String</code> 支持可变的文本，需要在堆中分配内存来放置这些内容，其分配大小在编译时是未知的，意味着：</p>
<ul>
<li>分配器需要在运行时请求内存</li>
<li>我们需要在使用完 <code>String</code> 之后归还那部分内存</li>
</ul>
<p>That first part is done by us: when we call <code>String::from</code>, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.</p>
<p>第一部分已经在调用 <code>String::from</code> 的时候完成了，执行后它获得了所需的内存。
这在编程语言中很常见。</p>
<p>然而第二部分就有点不一样了。在有**垃圾回收（GC）**的语言中，GC 会跟踪清理那些不再被占用的内存，我们无需为此操心。
如果没有 GC，归还内存就是我们程序员的责任了，就像声明时获取内存一样，释放内存时也要通过代码操作。
做好这一步是编程的历史性难题。如果忘记释放，就会浪费内存，如果过早释放，变量就无效了，
要是我们释放了两次，同样是个 bug。<code>allocate</code> 和 <code>free</code> 必须一对一配对。</p>
<p>Rust 另辟蹊径：变量离开作用域时，内存会被自动释放。请看例 4-1 的 <code>String</code> 版本：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}
</span></code></pre></pre>
<p>很自然地，在 <code>s</code> 离开作用域时，<code>String</code> 的内存会被归还到分配器。
在变量离开作用域时，Rust 自动为我们调用了一个特殊函数——<a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>，
<code>String</code> 的作者已经将回收内存的代码写到里面了。
Rust 会在遇到右花括号时自动调用 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++ 中，这种在变量生命周期结束时释放资源的方式称为 <strong>Resource Acquisition Is Initialization (RAII)</strong>。
如果你曾经接触过 RAII 模式，那么 Rust <code>drop</code> 函数会让你觉得很类似。</p>
</blockquote>
<p>这个模式对 Rust 代码的编写方式有深远的影响。虽然到现在为止看起来还很简单，
但是多个变量使用堆中的同一数据时，代码可能会出现一些意想不到的问题。接下来我们看看这些情况吧。</p>
<h4><a class="header" href="#变量和数据的交互方式move" id="变量和数据的交互方式move">变量和数据的交互方式：Move</a></h4>
<p>Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.</p>
<p>在 Rust 中，多个的变量可能以不同方式处理同一个数据，
我们来看看例 4-2，使用整形。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">例 4-2：把整形的 <code>x</code> 赋值到 <code>y</code></span></p>
<p>我们可以猜测其中发生的事情：<code>5</code> 绑定到 <code>x</code>，然后复制一份 <code>x</code> 的值，然后绑定到 <code>y</code>。
现在就有了 <code>x</code> 和 <code>y</code> 两个变量，都等于 <code>5</code>。事实上，确实是这样，因为整形是确定的简单值，而且确定大小。
这两个 <code>5</code> 都被推入栈中。</p>
<p>现在看看 <code>String</code> 的情况：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>这与前面一段代码很像，我们推测两者的工作方式也类似：
第二行获取 <code>s1</code> 的值的拷贝，然后绑定到 <code>s2</code>。但事实上不是这样的。</p>
<p>图 4-1 展示了 <code>String</code> 在底层的储存方式，它由三部分组成（图的左边）：一个指向储存着字符串内容的内存的指针、
长度还有容量。左边的数据储存在栈中，右边则是在堆中，里面储存着字符串的内容。</p>
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">图 4-1：在内存中，<code>String</code> 储存 <code>&quot;hello&quot;</code> 的值并绑定到 <code>s1</code></span></p>
<p>长度是 <code>String</code> 当前使用的内存，单位为 byte。容量是分配器给 <code>String</code> 分配的总内存，单位为 byte。
长度和容量是有区别的，但是我们暂时不用纠结这个问题，总之现在先忽略容量吧。</p>
<p>当将 <code>s1</code> 赋值给 <code>s2</code> 时，<code>String</code> 数据被复制了一份，也就是说，复制了指针、长度和容量这三个储存在栈中的值。
而指针指向的堆中的数据则不会复制。换言之，数据在内存中如图 4-2 所示。</p>
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">图 4-2: 内存中，<code>s2</code> 复制了 <code>s1</code> 的指针、长度和容量</span></p>
<p>而<strong>不会</strong>是图 4-3 这样，把堆的数据也复制一遍。如果 Rust 这么做，在堆中数据十分庞大的情况下，
<code>s2 = s1</code> 这个操作就会花费很多时间，影响运行时表现。</p>
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">图 4-3：如果 <code>s2 = s1</code> Rust 复制了堆里的数据</span></p>
<p>之前，我们提到当变量离开作用域，Rust 会自动调用 <code>drop</code> 函数清理堆中内存。
但图 4-2 所示，有两个数据的指针都指向同一个位置，这就成问题了：<code>s2</code> 和 <code>s1</code> 同时离开作用域，
它们会同时释放同一块内存，这被称为<strong>double free</strong>错误，是一个我们之前提到的内存安全问题。
释放内存两次会导致 memory corruption，造成潜在的安全漏洞。</p>
<p>为了保证内存安全，在这种情况下 Rust 有一个细节操作。与其复制一份已经分配的内存，
Rust 直接将 <code>s1</code> 视为不可用，因此 Rust 在<code>s1</code>离开作用域时就不需要释放内存了。
试试在 <code>s2</code> 创建后再使用 <code>s1</code> 会怎么样？结果是它不能用了：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<p>Rust 会报出一个这样的错误，防止你使用已经无效的引用：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre>
<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a <em>move</em>. In this example, we would say that
<code>s1</code> was <em>moved</em> into <code>s2</code>. So what actually happens is shown in Figure 4-4.</p>
<p>如果你之前听说过<strong>浅复制（shallow copy）<strong>和</strong>深复制（deep copy）</strong>，
只复制指针、长度和容量就类似浅复制。
但因为 Rust 会同时让之前的变量无效，所以就不称其为浅复制，而称为 <strong>move</strong>。
在这个例子里，我们可以说 <code>s1</code> <strong>移动到了</strong> <code>s2</code>，所以实际情况如图 4-4 所示。</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">图 4-4：内存中 <code>s1</code> 已失效</span></p>
<p>这就解决了问题，只有 <code>s2</code> 有效的情况下，离开作用域时只有它被释放，搞定。</p>
<p>这是一个设计上的选择，Rust 永远不会自动深复制你的数据，任何
<strong>默认的</strong>复制为了保证运行时性能都会选择最快捷的方式。</p>
<h4><a class="header" href="#变量和数据的交互方式clone" id="变量和数据的交互方式clone">变量和数据的交互方式：Clone</a></h4>
<p>如果我们<strong>就是</strong>需要深复制堆里的 <code>String</code> 数据，我们可以使用通用方法 <code>clone</code>。
我们将会在第五章讨论方法语法，但毕竟方法是编程语言的常见特性，大家应该都已经接触过了。</p>
<p>使用 <code>clone</code> 方法的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>这样就产生了图 4-3 的效果，堆中的数据<strong>也成功被复制</strong>。</p>
<p>看到 <code>clone</code> 被调用，你要立刻反应到代码的性能可能会可能不高，明白地告诉你这些代码会有点与众不同。</p>
<h4><a class="header" href="#栈数据专用的copy" id="栈数据专用的copy">栈数据专用的：Copy</a></h4>
<p>还有一个小问题我们还未谈到。例 4-2 中代码使用了整形数，它正常工作，完全合理。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>但这代码似乎和我们刚学到的有冲突：我们没有用 <code>clone</code>，但是 <code>x</code> 依然可用，没有被 move 到 <code>y</code>。</p>
<p>原因是整形等类型在编译时拥有确定的大小，并<strong>可以完全储存在栈中</strong>，所以复制实际的值也十分快捷，
也就没有必要在创建 <code>y</code> 后让 <code>x</code> 无效了。换言之，深浅复制在这里毫无区别，
用不用 <code>clone</code> 不会有什么不同。</p>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on
types like integers that are stored on the stack (we’ll talk more about traits
in Chapter 10). If a type implements the <code>Copy</code> trait, an older variable is
still usable after assignment. </p>
<p>Rust won’t let us annotate a type with the
<code>Copy</code> trait if the type, or any of its parts, has implemented the <code>Drop</code>
trait. If the type needs something special to happen when the value goes out of
scope and we add the <code>Copy</code> annotation to that type, we’ll get a compile-time
error. To learn about how to add the <code>Copy</code> annotation to your type to
implement the trait, see <a href="appendix-03-derivable-traits.html">“Derivable Traits”</a><!-- ignore -->
in Appendix C.</p>
<p>Rust 有一种特别的写法，称为 <code>Copy</code> 特性（trait）。
我们将在第十章了解更多关于 trait 的东西
如果一个类型实现了 <code>Copy</code> 特性，旧变量在赋值后依然可用。
Rust </p>
<p>So what types implement the <code>Copy</code> trait? You can check the documentation for
the given type to be sure, but as a general rule, any group of simple scalar
values can implement <code>Copy</code>, and nothing that requires allocation or is some
form of resource can implement <code>Copy</code>. Here are some of the types that
implement <code>Copy</code>:</p>
<ul>
<li>所有整形，如 <code>u32</code></li>
<li>布尔值 <code>bool</code>，值为 <code>true</code> 和 <code>false</code></li>
<li>所有浮点型，如 <code>f64</code></li>
<li>字符型 <code>char</code></li>
<li>元组，如果只包含指定类型，也可以实现 <code>Copy</code>，例如 <code>(i32, i32)</code> 可以 <code>Copy</code>，<code>(i32, String)</code> 不行</li>
</ul>
<h3><a class="header" href="#ownership-和函数" id="ownership-和函数">Ownership 和函数</a></h3>
<p>The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.</p>
<p>向函数传入一个值与赋值一个变量是一样的，所以向函数传入变量就像赋值一样产生 move 或者 copy。
例 4-3 展示了变量进入与离开作用域。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</code></pre></pre>
<p><span class="caption">例 4-3：函数 ownership 和作用域</span></p>
<p>If we tried to use <code>s</code> after the call to <code>takes_ownership</code>, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to <code>main</code> that uses <code>s</code> and <code>x</code> to see where you can use them and where
the ownership rules prevent you from doing so.</p>
<p>如果在 <code>takes_ownership</code> 后访问 <code>s</code>，Rust 会抛出编译错误。这种静态检测提早提醒我们修复错误。
你可以尝试在 <code>main</code> 添加一些代码，看看 <code>s</code> 和 <code>x</code> 的使用范围。</p>
<h3><a class="header" href="#返回值与作用域" id="返回值与作用域">返回值与作用域</a></h3>
<p>返回值也能转移 ownership，请看例 4-4。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from(&quot;hello&quot;); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</code></pre></pre>
<p><span class="caption">例 4-4：转移返回值的 ownership</span></p>
<p>变量的 ownership 遵循相同的模式：一个变量赋值到另一个变量会 move 它。
当一个包含堆数据的变量离开作用域，它的值会被 <code>drop</code> 清理——
除非这些数据已经被 move 到了其他变量。</p>
<p>Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
It’s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.</p>
<p>每个函数都获取 ownership 之后再返还 ownership 会十分麻烦，我们可不可以在不获取 ownership 的情况下使用这个值呢？</p>
<p>可以像例 4-5 使用元组返回多个值。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">例 4-5：归还参数的 ownership</span></p>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
<em>references</em>.</p>
<p>但每次都这么做就有点麻烦了，这本应是很普通的需求，幸运地，Rust 有一个解决这个问题的特性，
叫做 <strong>引用（reference）</strong>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        

    </body>
</html>
